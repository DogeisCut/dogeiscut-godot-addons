@tool
@icon("res://addons/scratch_project_importer/icons/scratch_sprite.svg")
extends Sprite2D
class_name ScratchSprite
## The base class tasked with providing and replicating many of Scratch's visual functionality.
## @experimental: This is VERY prone to bugs and inacuracies to Scratch. I've tried my best.

## The shader responsible for replicating Scratch's graphic effects.
const SCRATCH_SPRITE_SHADER = preload("scratch_sprite_shader.tres")

## Keeps track of the project root, this should always be a [ScratchProjectRoot], useful for storing global vars.
@onready var root: ScratchProjectRoot = $".."

## An array of every clone this sprite has created.
var clones: Array[ScratchSprite]
## Is this instance of this sprite a clone or not?
var is_clone: bool = false

## The current costume index, used by all the values below.
@export var current_costume: = 0: 
	set(to):
		current_costume = clamp(to, 0, max(len(costumes)-1,0))
		update_costume_properties()
		queue_redraw()
	get:
		return current_costume
## An array of all the costumes of this sprite, generated by the plugin.
@export var costumes: Array[ImageTexture]
## An array of all the costume names of this sprite, generated by the plugin.
@export var costume_names: Array[StringName]
## An array of all the costume offsets/pivots of this sprite, generated by the plugin.
@export var offsets: Array[Vector2]
## An array of all the costume bitmap resolutions of this sprite, generated by the plugin.
@export var bitmap_resolutions: Array[float]
## An array of arrays of PackedVector2 arrays containing the hibox of each segment of a costume, generated by the plugin.
@export var costume_collisons: Array
## The facing direction of this sprite, in Scratch units.
@export var direction: float: 
	set(to):
		direction = fmod((to + 180), 360) - 180
		
		update_costume_properties()
		queue_redraw()
	get:
		return direction
## The size of this sprite, in Scratch units.
@export var scratch_size: float: 
	set(to):
		scratch_size = to
		
		update_costume_properties()
		queue_redraw()
	get:
		return scratch_size
## The position of this sprite, in Scratch units.
@export var scratch_position: Vector2: 
	set(to):
		scratch_position = to
		
		update_costume_properties()
		queue_redraw()
	get:
		return scratch_position
## The rotation style enum, defines what happens visually as it rotates.
enum RotationStyle {
	## Will rotate as expected, normally and freely.
	ALL_AROUND,
	## Will visually snap to 90 or -90, flipping vertically if -90.
	LEFT_RIGHT,
	## Visually doesnt rotate at all.
	DONT_ROTATE
}
## The rotation style of this sprite, defines what happens visually as it rotates. See [enum ScratchSprite.RotationStyle] for details.
@export var rotation_style: RotationStyle

#@onready var debug_polygon: Polygon2D = Polygon2D.new()

## Overwritten to update materials as needed.
func _enter_tree() -> void:
	if !material:
		material = ShaderMaterial.new()
		material.shader = SCRATCH_SPRITE_SHADER
	update_costume_properties()

## Forces the sprite to update all its current information to be that of the [param current_costume] value, called every [method ScratchSprite._draw] call.
func update_costume_properties() -> void:
	position = Vector2(scratch_position.x, -scratch_position.y)*2
	if !costumes.is_empty():
		scale = Vector2(scratch_size,scratch_size)/100.0*(2 if (bitmap_resolutions[current_costume] == 1) else 1)
		texture = costumes[current_costume]
		offset = offsets[current_costume]-(texture.get_size()/2)
		offset *= -1
	match(rotation_style):
		RotationStyle.LEFT_RIGHT:
			rotation_degrees = 0
			if direction>0:
				flip_h = false
			elif direction<0:
				flip_h = true
				offset.x *= -1
		RotationStyle.DONT_ROTATE:
			rotation_degrees = 0
			flip_h = false
		_:
			rotation_degrees = -fmod((90 - direction), 360)
			flip_h = false

## Overwritten to call [method ScratchSprite.update_costume_properties].
func _draw() -> void:
	update_costume_properties()
	#debug_polygon.top_level = true
	#if !costume_collisons[current_costume].is_empty():
		#debug_polygon.polygon = transform_packed_vector2_array(self, costume_collisons[current_costume][0])
	#debug_polygon.color = Color(0.0, 1.0, 0.0, 0.25)
	#debug_polygon.z_index = 128
	#add_child(debug_polygon)
	#debug_polygon.global_position = Vector2.ZERO

## Converts Scratch direction units into degrees rotation.
func scratch_direction_to_rotation(direction_deg: float) -> float:
	return -fmod((90 - direction_deg), 360)

## Converts degrees rotation into Scratch direction units.
func rotation_to_scratch_direction(rotation_deg: float) -> float:
	return fmod((rotation_deg + 180), 360) - 180

## Converts a variant into a float, Scratch style.
func variant_to_float(variant) -> float:
	match typeof(variant):
		TYPE_FLOAT:
			return variant
		TYPE_BOOL:
			return float(int(variant))
		TYPE_INT:
			return float(variant)
		TYPE_STRING:
			return variant.to_float()
		_:
			return 0.0

## Converts a variant into a bool, Scratch style.
func variant_to_bool(variant) -> bool:
	match typeof(variant):
		TYPE_FLOAT:
			return float(variant) != 0.0
		TYPE_BOOL:
			return variant
		TYPE_INT:
			return float(variant) != 0.0
		TYPE_STRING:
			return variant.to_float() != 0.0
		_:
			return false

## I forget why this is here.
var rotation_style_string_map = {
	"all around": RotationStyle.ALL_AROUND,
	"left-right": RotationStyle.LEFT_RIGHT,
	"don't rotate": RotationStyle.DONT_ROTATE,
}

## A quick way to reset all the shader params.
func reset_graphics_effects() -> void:
	material.set_shader_parameter("color", 0)
	material.set_shader_parameter("fisheye", 0)
	material.set_shader_parameter("whirl", 0)
	material.set_shader_parameter("pixelate", 0)
	material.set_shader_parameter("brightness", 0)
	material.set_shader_parameter("ghost", 0)
	material.set_shader_parameter("mosaic", 0)

## Called every project tick.
## Override this to call code when you need this.
## @deprecated: use a [code]while true[/code] loop with [code]await ticked.true[/code] in a self calling lambda inside wherever needed instead.
## [codeblock]
## (func():
##    while true:
##        # ...
##        await root.ticked
##).call()
func _tick() -> void:
	pass

## Called when the project starts for the first time, this differs from [method Node._ready] as it will not be called when making instances
## Override this to call code when you need this.
func _green_flag() -> void: #this differs from _ready as it will not be called when making instances
	pass

## Performs a simple AABB collision check between two [ScratchSprite]s
## @deprecated: Use [method ScratchSprite.is_touching] instead.
func is_touching_simple(sprite: ScratchSprite) -> bool:
	var touching = false
	update_costume_properties()
	sprite.update_costume_properties()
	var rect1 = get_rect()
	rect1 = rect1.grow(2)
	rect1.position += position
	rect1.position += offset
	var rect2 = sprite.get_rect()
	rect2 = rect2.grow(2)
	rect2.position += sprite.position
	rect1.position += sprite.offset
	touching = rect1.intersects(rect2)
	for clone in sprite.clones:
		touching = touching or is_touching_simple(clone)
	return touching

# this should probably just do aabb box collisions for every pixel of the sprite tbh
## Performs a complex sprite-based polignal collision check between two [ScratchSprite]s
## Collision is disabled when one of the two sprites are hidden.
func is_touching(sprite: ScratchSprite) -> bool: #unoptimised <3
	update_costume_properties()
	sprite.update_costume_properties()
	
	#var rect1 = get_rect()
	#rect1 = rect1.grow(10)
	#rect1.position += position
	#rect1.position += offset
	#var rect2 = sprite.get_rect()
	#rect2 = rect2.grow(10)
	#rect2.position += sprite.position
	#rect2.position += sprite.offset
	#if !rect1.intersects(rect2): return false
	
	if !sprite.visible or !visible:
		return false 
	
	var touching = false
	if current_costume > len(costume_collisons)-1: return false
	if sprite.current_costume > len(sprite.costume_collisons)-1: return false
	var polygon_list1: Array = costume_collisons[current_costume]
	var polygon_list2: Array = sprite.costume_collisons[sprite.current_costume]
	for polygon in polygon_list1:
		if polygon.is_empty(): continue
		for polygon2 in polygon_list2:
			if polygon2.is_empty(): continue
			touching = touching or !Geometry2D.intersect_polygons(transform_packed_vector2_array(self, polygon), transform_packed_vector2_array(sprite, polygon2)).is_empty()
	for clone in sprite.clones:
		touching = touching or is_touching(clone)
	return touching

## Used internally by the polygon collision to transform the collision.
func transform_packed_vector2_array(sprite: ScratchSprite, array: PackedVector2Array) -> PackedVector2Array:
	var result = PackedVector2Array()
	for i in range(array.size()):
		var transformed_vector = sprite.global_transform.basis_xform((array[i] - Vector2(sprite.texture.get_width(), sprite.texture.get_height())/2.0) * Vector2((-1 if sprite.flip_h else 1), 1) + sprite.offset) + sprite.global_transform.origin
		result.append(transformed_vector)
	return result

## Thanks to a little quirk of Scratch, their modulo differs slightly when handling floats and negative numbers than that of Godot.
func scratch_modulo(a: float, b: float) -> float: #thanks scratch
	var result = fmod(a, b)
	if result < 0:
		result += b
	return result

## Called when a sprite is first made as a clone.
## Override this to call code when you need this.
func _when_i_start_as_a_clone() -> void:
	pass

## Creates a clone of this sprite, Scratch style.
func clone_myself() -> ScratchSprite:
	var clone = duplicate()
	root.add_child(clone)
	clones.append(clone)
	clone.material = ShaderMaterial.new()
	clone.material.shader = SCRATCH_SPRITE_SHADER
	clone._when_i_start_as_a_clone()
	clone.is_clone = true
	return clone

## Deletes this clone if called in a clone.
func delete_this_clone() -> void:
	if is_clone: 
		clones.erase(self)
		queue_free()

## Switches the costume of the sprite, by name or number, Scratch style.
func switch_costume_to(costume) -> void:
	match typeof(costume):
		TYPE_FLOAT:
			current_costume = costume - 1
		TYPE_INT:
			current_costume = costume - 1
		_:
			current_costume = costume_names.find(costume)
